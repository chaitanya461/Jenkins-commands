ENV VARIABLES:

It is a way to pass configuration information to containers running within pods. To set Env vars it include envFrom field in the configuration file.

ENV: Allows you to set environment variables for a container, specifying a value directly for each variable throug CLI/ Command prompt

ENVFROM: PASSING Variables FROM FILE 2 Types, configmaps and secrets

CONFIGMAPS & SECRETS:

D

It is used to store the data in key-value pair, files, or command-line arguments that can be used by pods, containers in cluster.

But the data should be non-confidential. It does not provide security and encryption.

If you want to provide Enryption use Secrets in K8S.

Limit of the configmap is only 1MB

But if you want to store more than 1MB configmap data mount volume or use a separate database or a file service

Example with ENV:

kubectl create deploy newdb-image-mariadb having mariadb]

[This will create a deployment called newdb with single pod

kubectl get pods

kubectl logs newdb-794dd57dbc-tr7s9 [It is crashed because we haven't specified the passsowrd for MariaDB]

kubectl set env deploy newdb MYSQL_ROOT_PASSWORD-root123456

kubectl get pods [ Now it will be in running state, but we are passing password directly from command]

kubectl delete deploy newdb

kubectl create deploy newdb-image-mariadb

kubectl get pods [This will fail because no env variable]

first create secrets, 2 ways to create, from CLI or from File

kubectl create secret generic password--from-literal-ROOT_PASSWORD=reyaz123 (from cli) value literal meaning direct

kubectl create secret generic my-secret-from-env-file=vars (from file)

kubectl get secrets

kubectl describe secret my-secret [Name of the secret is my-secret]

kubectl set env deploy newdb-from-secrets/password

kubectl get pods [This will fail because we have not mention the MYSQL_ prefix]

kubectl set env deploy newdb-from-secret/password--prefix=MYSQL_

without passing prefix we cant make the pod running status

TO SEE SECRETS:

kubectl get secrets password -o yaml

echo -n "LKJSKFHJHi" | base64 -d

or

echo -n "LKJSKFHJHi" base64-decode

kubectl delete deploy newdb

container writes log data to a shared volume, and the sidecar container serves these logs over HTTP using nginx

vi sidecar.yml

apiVersion: v1
kind: Pod
metadata:
  name: log-aggregator-pod
spec:
  containers:
  - name: app-container
    image: alpine
    command: ["/bin/sh", "-c"]
    args: ["while true; do date >> /var/log/app.log; sleep 5; done"]
    volumeMounts:
    - name: shared-logs
      mountPath: /var/log
  - name: sidecar-container
    image: nginx
    volumeMounts:
    - name: shared-logs
      mountPath: /usr/share/nginx/html
  volumes:
  - name: shared-logs
    emptyDir: {}

----------_--------------------------------------------------------------

INGRESS:

Ingress is a service to expose application, but we already have cluster ip, node port and load balancer, let see

Ingress helps to expose HTTP and HTTPS routes from outside of the Cluster

Ingress supports Host based routing and path based routing

ingress supports load balancing and SSL termination

IT redirect the incoming requests to the right services based on the web url or path in the address

ingress provides encryption feature and helps to balance the load of the applications

Explain Host based and Path based

Host Based Routing: ex: boom.com, web.boom.com, admin.boom.com

Path based routing: boom.com/hello, boom.com/admin, Paytm.com/movies, Paytm.com/recharge etc

but services like load balancer, cluster ip, node port etc donest have these features

General load balancer routes the traffic based on ports and cant handle URL based routing

kubectl get ing-> shows ingress service, no ingress service

To install ingress, firstly we have to install nginx ingress controller:
command:

kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.3.0/deploy/static/provider/cloud/deploy.yaml

kubectl get pods

kubectl get deploy

kubectl get svc

kubectl get ingress

kubectl get service



vi httpd.yml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: httpd
  labels:
    app: httpd
spec:
  replicas: 1
  selector:
    matchLabels:
      app: httpd
  template:
    metadata:
      labels:
        app: httpd
    spec:
      containers:
      - name: httpd
        image: httpd
        ports:
        - containerPort: 80
        env:
        - name: TITLE
          value: "APACHE APP2"
---
apiVersion: v1
kind: Service
metadata:
  name: httpd
spec:
  type: ClusterIP
  ports:
  - port: 80
  selector:
    app: httpd

vi nginx.yml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
  labels:
    app: nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80
        env:
        - name: TITLE
          value: "NGINX APP1"
---
apiVersion: v1
kind: Service
metadata:
  name: nginx
spec:
  type: ClusterIP
  ports:
  - port: 80
  selector:
    app: nginx

vi ingrees.yml

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: k8s-ingress
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
    nginx.ingress.kubernetes.io/use-regex: "true"
    nginx.ingress.kubernetes.io/rewrite-target: /$2
spec:
  ingressClassName: nginx
  rules:
  - http:
      paths:
      - path: /nginx(/.*)(.*)
        pathType: ImplementationSpecific
        backend:
          service:
            name: nginx
            port:
              number: 80
      - path: /httpd(/.*)(.*)
        pathType: ImplementationSpecific
        backend:
          service:
            name: httpd
            port:
              number: 80
      - path: /(.*)
        pathType: ImplementationSpecific
        backend:
          service:
            name: nginx
            port:
              number: 80

---------------------------------------_---------------------------------------------
